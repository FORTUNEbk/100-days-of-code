  #                                                                               100 DAYS OF CODE.
# Day 1
This code is a basic example of a Java program, demonstrating the fundamental structure of a Java class and the use of the System.out.println method to print text to the console. This type of program is commonly used as an introductory example for learning Java programming, often referred to as the "Hello World" program.

# Day 2
Within the main method, three variables are declared and initialized with specific values: an integer num set to 21, a double num2 set to 30.0, and a string text set to "Hello". The program then uses the System.out.println method to print these values to the console, each preceded by a descriptive label. Specifically, it prints "Integer: 21" for the integer, "Double: 30.0" for the double, and "String: Hello" for the string. This code demonstrates basic variable declaration, initialization, and output in Java, illustrating how different data types can be used and displayed in a straightforward manner.

# Day 3
It creates an instance of the Scanner class to read input from the standard input stream (typically the keyboard).
It prompts the user to input a string, reads the input using scanner.nextLine(), and stores it in the variable text.
It prompts the user to input an integer, reads the input as a string, converts it to an integer using Integer.valueOf(scanner.nextLine()), and stores it in the variable number.
It prompts the user to input a double, reads the input as a string, converts it to a double using Double.valueOf(scanner.nextLine()), and stores it in the variable decimal.
It prompts the user to input a boolean, reads the input as a string, converts it to a boolean using Boolean.valueOf(scanner.nextLine()), and stores it in the variable value.
It then prints each of the captured inputs back to the console with descriptive messages.
Finally, it closes the Scanner object to release the associated resources.


# Day 4_1
Inside the main method, two integer variables, num1 and num2, are declared and initialized with the values 225 and 384, respectively.
The program then performs four basic arithmetic operations using these two variables. It calculates the sum, difference, product, and quotient of num1 and num2. The results of these calculations are stored in separate variables: sum, subtraction, multiplication, and division. Note that the division operation explicitly casts one of the integers (num1) to a double to ensure that the result is a double and not an integer. This allows for decimal places in the division result, providing a more accurate quotient.

# Day 4_2
Inside this class, the main method is defined, which serves as the entry point of the program. When the program runs, it first creates a Scanner object named scanner to read input from the standard input stream, typically the keyboard. The program prompts the user to enter the length of the rectangle with a message printed to the console. It then reads the user's input as a string, converts this string to an integer using Integer.valueOf, and assigns the resulting integer value to the variable length. A similar process is followed to prompt the user for the width of the rectangle: the program prints a message, reads the input, converts it to an integer, and stores it in the variable width.
With both the length and width values obtained, the program calculates the area of the rectangle by multiplying these two values. The calculated area is stored in the variable area. The program then prints the area to the console, providing a message that indicates the value being displayed.

# Day 4_3
The program prompts the user to enter the length of the rectangle by printing a message to the console. It then reads the user’s input as a string, converts this string to a double using Double.valueOf, and stores the resulting value in the variable length. This allows the program to handle decimal values, accommodating more precise measurements.
The program repeats the same process to obtain the width of the rectangle: it prompts the user, reads the input, converts it to a double, and stores it in the variable width. With both the length and width captured as decimal numbers, the program calculates the area of the rectangle by multiplying these two values. The result, stored in the variable area, is also a double, ensuring that the calculation can handle and maintain decimal precision.
Finally, the program prints the calculated area to the console with a message indicating the result. The use of double data type throughout the program allows it to handle decimal inputs and outputs, making it suitable for applications requiring precision.

# Day 5
It begins by prompting the user to enter their age, reading this input as a string and checking if it's empty to ensure valid data entry. If the input is empty, the program informs the user that a blank entry is not accepted and terminates gracefully. Upon receiving a valid age input, the program converts it to an integer and checks if it's less than 150. If the age is within a valid range, it prints a message stating the age. If the age is 150 or more, it outputs "Impossible" and exits.
After confirming a valid age, the program proceeds to increment the age by 1 for display purposes and prints this incremented value. It then resets the age back to its original value and calculates the factorial of the age using a loop. Additionally, it computes the sum of integers from 1 to the age and also calculates a subtraction value, which accumulates negative values due to its decrementing operation within the same loop.
Following these calculations, the program computes the average of the values from 1 to the age, ensuring accuracy by using a double type to account for decimal places in the division operation. It also checks if the age is an even number and prepares a corresponding text message for output.
Finally, the program prints the results of these calculations:
The factorial of the age.
The sum of integers up to the age.

# Day 6
First, it initializes a string strInt with the value "123" and converts it to an integer using Integer.parseInt(), storing the result in the variable intValue. This conversion is printed to the console. Next, a string strFloat with the value "123.45" is converted to a float using Float.parseFloat(), and the result is stored in the variable floatValue, which is then printed to the console.
Following these conversions, an integer number is initialized with the value 456. The program converts this integer to a string using two different methods. The first method, String.valueOf(), converts the integer to a string and stores the result in the variable strFromValueOf, which is printed to the console. The second method, Integer.toString(), also converts the integer to a string and stores the result in the variable strFromToString, which is similarly printed.

# Day 7
Initially, two double variables, num1 and num2, are declared and initialized with the values -5.4 and 3.7, respectively. The program then uses the Math.max() method to determine the maximum value between num1 and num2, storing the result in the variable max and printing it to the console. Similarly, the Math.min() method is used to find the minimum value between num1 and num2, with the result stored in min and printed.
The code proceeds to demonstrate the calculation of the square root of a number. A double variable number is initialized with the value 16.0, and the Math.sqrt() method is used to compute its square root, storing the result in the variable sqrt and printing it. The program then illustrates the use of Math.floor() and Math.ceil() methods on a double variable floatNum initialized with the value 5.67. These methods compute the largest integer less than or equal to floatNum and the smallest integer greater than or equal to floatNum, respectively. The results are stored in floor and ceil and printed to the console.
The cumulative subtraction of integers up to the age.
The calculated average with precision to two decimal places.
A message indicating if the age is an even number.
To ensure proper resource management, the program closes the Scanner object used for input after completing all calculations and outputs.

# Day 8
The Day8 class in the provided code is designed to perform three distinct operations based on user input: checking if a number is odd or even, finding the largest of three numbers, and determining if a given year is a leap year. The class utilizes the Scanner class from the java.util package to read user inputs from the console.
The main method is the entry point of the program. It starts by creating a Scanner object to capture user input and presents a menu to the user with three options: "Check Odd or Even," "Find Largest of Three Numbers," and "Check Leap Year." The user is prompted to enter their choice, which is then read as an integer. Based on the user’s choice, a corresponding method is invoked using a switch-case structure.
The checkOddEven method prompts the user to enter an integer and then determines if the number is odd or even. This is done by checking the remainder of the number when divided by 2 using the modulus operator (%). If the remainder is zero, the number is even; otherwise, it is odd. The result is printed to the console.
The findLargestOfThree method asks the user to input three double values. It then determines the largest of the three numbers using a series of conditional statements. The result is stored in a variable named largest, which is then printed out.
The checkLeapYear method prompts the user to enter a year. It checks if the year is a leap year using the standard leap year rules: a year is a leap year if it is divisible by 4 but not by 100, or if it is divisible by 400. The result is printed to the console.

# Day 9
The program begins by importing the Scanner class from the java.util package to facilitate user input. The class Day9 contains the main method, which serves as the entry point for the program's execution.
Within the main method, a Scanner object named scanner is instantiated to read input from the user. The program then prompts the user to "Enter your percentage:" and reads the inputted integer value using the nextInt() method of the Scanner class. This integer, representing the percentage score, is stored in the variable percentage.
To determine the corresponding letter grade, the program first calculates the grade range by dividing the percentage by 10. This division simplifies the percentage into a more manageable range, allowing the switch statement to handle it effectively. The result of this division is stored in the variable gradeRange.
The switch statement evaluates the value of gradeRange and assigns a letter grade based on the case that matches the value. If gradeRange is 10 or 9, the letter grade 'A' is assigned. If it is 8, the grade 'B' is assigned. Similarly, if it is 7, 'C' is assigned, and if it is 6, 'D' is assigned. Any other value falls under the default case, assigning the grade 'F'.

# Day 10_1
The Day10_1 class is a Java program that calculates the sum of all integers from 1 to a user-provided number using three different loop constructs: a for loop, a while loop, and a do-while loop. It begins by importing the Scanner class to allow for user input. In the main method, a Scanner object named scanner is instantiated to read input from the console. The user is prompted to enter an integer, which is then stored in the variable n.
The program proceeds to calculate the sum of integers from 1 to n using a for loop. An integer variable sumFor is initialized to 0. The for loop iterates from 1 to n, adding each value of i to sumFor. After the loop completes, the result is printed to the console.
Next, the sum is calculated using a while loop. The variable sumWhile is initialized to 0, and the loop variable i is initialized to 1. The while loop continues to execute as long as i is less than or equal to n. Within the loop, i is added to sumWhile, and then i is incremented by 1. After exiting the loop, the result is printed to the console.

# Day 10_2
The Day10_2 class is a Java program designed to calculate the sum of all even integers from 1 to a user-provided number. The program begins by importing the Scanner class to facilitate user input. In the main method, a Scanner object named scanner is created to read input from the console. The user is prompted to enter an integer, which is stored in the variable number.
An integer variable sum is initialized to 0 to keep track of the cumulative sum of the even integers. The program then uses a for loop to iterate through all integers from 1 to the value of number. Within the loop, an if statement checks if the current integer i is odd by using the modulus operator (i % 2 != 0). If i is odd, the continue statement is executed, which skips the rest of the loop body and proceeds to the next iteration.
If i is even, the continue statement is bypassed, and the value of i is added to the sum variable. This process continues until the loop has iterated through all integers from 1 to number.
After the loop completes, the program prints the total sum of the even integers from 1 to the user-provided number. This final result is displayed to the console with a descriptive message.

# Day 10_3
The Day10_3 class is a Java program that demonstrates generating random numbers and checking conditions using a while loop. It begins by importing the Random class from the java.util package to facilitate the generation of random numbers. In the main method, a Random object named random is instantiated.
Inside the while loop, which runs indefinitely (while (true)), a random integer num is generated using the nextInt(100) + 1 method of the Random class. This generates a random integer between 1 and 100 inclusive and assigns it to num. The generated number num is then printed to the console using System.out.println("Generated number: " + num).
Following the print statement, an if statement checks if the generated number num is divisible by both 5 and 7. This is done using the condition num % 5 == 0 && num % 7 == 0. If this condition is true, indicating that num is divisible by both 5 and 7 without remainder, the program executes the statements within the if block.
Within the if block, it prints a message indicating that a number divisible by both 5 and 7 has been found, along with the value of num. After printing this message, the break statement is encountered, which terminates the while loop. This break statement exits the loop immediately upon finding a number that satisfies the condition, ensuring that the program does not continue generating numbers unnecessarily once the desired number is found.

# Day 11
The Day11 class in Java demonstrates various operations on strings using static methods. Each method encapsulates a specific string manipulation or utility function, and the main method showcases the usage of these methods through a series of examples.
The stringLength method takes a string as input and returns its length using the length() method. The stringConcatenation method concatenates two strings using the + operator and returns the result. The stringComparison method compares two strings for equality using the equals() method and returns a boolean indicating if they are the same.
The stringToUppercase method converts a string to uppercase using the toUpperCase() method, while the stringToLowercase method converts a string to lowercase using the toLowerCase() method. The stringTrimming method removes any leading and trailing whitespace from a string using the trim() method.
For substring extraction, the substringExtraction method takes a string and two integer indices, returning the substring from the start index to the end index using the substring() method. The stringSplitting method splits a string into an array of substrings based on a specified delimiter using the split() method.
The stringReversal method reverses a string by converting it to a StringBuilder, calling the reverse() method, and converting it back to a string. The stringSearching method checks if a substring exists within a string using the contains() method, returning a boolean result.
In the main method, various string operations are demonstrated. It starts by defining four strings: str1 (" Hello, World! "), str2 ("Java"), str3 ("hello"), and str4 ("HELLO"). The string length of str1 is printed, followed by the result of concatenating str1 and str2. The method then compares str1 with str2 and str3 with str4 (both converted to lowercase for case-insensitive comparison).
Next, the methods to convert str1 to uppercase and lowercase are demonstrated, followed by trimming the whitespace from str1. A substring of str1 from index 1 to 6 is extracted and printed. The string splitting functionality is demonstrated by splitting str1 using a comma delimiter, and the resulting substrings are printed.

# Day 12
Day12 that contains a main method. This method serves as the entry point of the program. Within the main method, two objects are created, one of the StringBuffer class and one of the StringBuilder class, both initialized with the string "Hello".
For the StringBuffer object, the append method is called twice: first to append a space character (" ") and then to append the string "World". The resulting concatenated string is then printed to the console with the label "StringBuffer: ".
Similarly, for the StringBuilder object, the append method is used twice in the same manner: first to append a space character and then to append the string "World". The concatenated string is then printed to the console with the label "StringBuilder: ".
This code demonstrates the usage of StringBuffer and StringBuilder for modifying strings in Java, highlighting their ability to efficiently handle string concatenations. The key difference is that StringBuffer is synchronized and thread-safe, making it suitable for use in multi-threaded environments, while StringBuilder is not synchronized and thus more efficient for use in single-threaded environments.

# Day 13_1
Inside the main method, an array of integers named numbers is initialized with the values {10, 20, 30, 40, 50}.
Next, an integer variable sum is initialized to 0. A for-each loop is used to iterate over each element in the numbers array. During each iteration, the current element (represented by the variable num) is added to sum, thus calculating the total sum of all elements in the array.
After the loop, a double variable average is calculated by dividing the sum by the length of the numbers array. To ensure the division is performed as floating-point division, sum is explicitly cast to double.
Finally, the average value is printed to the console using System.out.println, which outputs the message "The average is: " followed by the calculated average value.

# Day 13_2
It contains a main method that serves as the entry point of the Java application. Within the main method, an integer array named sourceArray is initialized with the values {10, 20, 30, 40, 50}. Following this, another integer array named destinationArray is declared with the same length as sourceArray.
The program then uses a for loop to iterate over each index of sourceArray. During each iteration, the value at the current index in sourceArray is copied to the corresponding index in destinationArray. This loop effectively duplicates the contents of sourceArray into destinationArray.
After copying the elements, the program prints "Destination array: " to the console. It then uses another for-each loop to iterate over each element in destinationArray, printing each element followed by a space. This results in the entire contents of destinationArray being displayed on a single line in the console.

# Day 14
 It contains a main method and several helper methods for array operations. The main method initializes a two-dimensional array array with predefined integer values and performs various operations on it.
First, the main method prints the original array to the console using the printArray method, which iterates through the array and prints its elements in a formatted manner. Then, it calls the maxInRows method to find the maximum values in each row of the array. This method iterates through each row, finds the maximum value in each row, and stores these values in a new array maxValues, which is then printed using the printArray method.
Next, the main method calls the maxInColumns method to find the maximum values in each column of the array. This method iterates through each column, finds the maximum value in each column, and stores these values in a new array maxValues, which is also printed using the printArray method.
After that, the main method calls the transpose method to transpose the original array. The transpose method swaps the rows and columns of the array, creating a new transposed array transposed, which is then printed using the printArray method.
The printArray method is overloaded to handle both one-dimensional and two-dimensional arrays. For two-dimensional arrays, it prints each element of each row followed by a space and a newline after each row. For one-dimensional arrays, it prints each element followed by a space and a newline at the end.

# Day 15
Day15, which contains a main method and a helper method for manipulating an ArrayList of strings representing the days of the week. The program performs several operations on this list, including sorting and removing specific elements.
First, the main method initializes an ArrayList named weekdays and populates it with the names of the days from Monday to Sunday. It then prints the original list to the console.
Next, the program sorts the weekdays list in increasing alphabetical order using the Collections.sort method, which sorts the elements in the list. The sorted list is then printed to the console.
Following this, the program sorts the weekdays list in decreasing alphabetical order by using Collections.sort in combination with Collections.reverseOrder. The Collections.reverseOrder method provides a comparator that sorts the elements in reverse order. The resulting list is printed to the console.
The program then declares a character variable removeChar with the value 'T'. This character is used to remove elements from the weekdays list that start with 'T'. The removeElementsStartingWith method is called with the weekdays list and the removeChar as arguments. This method uses the removeIf method along with a lambda expression (day -> day.charAt(0) == startChar) to remove any elements whose first character matches removeChar. Finally, the modified list is printed to the console.

# Day 16
This Java program demonstrates the use of enums to represent a fixed set of constants, specifically the days of the week. It defines a public class named Day16 that contains an enum called Weekdays. The Weekdays enum lists all the days of the week: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, and SUNDAY.
Within the Day16 class, the main method serves as the entry point of the program. Inside the main method, a for-each loop iterates over all the values of the Weekdays enum using the values() method, which returns an array of all the enum constants. For each day in the enum, the program prints the name of the day to the console.

# Day 17
This Java program demonstrates various functionalities of the java.time package to manipulate and format dates and times. Initially, it imports necessary classes for date and time manipulation (java.time.* and java.time.format.DateTimeFormatter). The Day17 class includes a main method, which serves as the entry point of the program.
The program starts by retrieving the current date using LocalDate.now() and prints it. It then gets the current time in milliseconds since the Unix epoch (January 1, 1970) using System.currentTimeMillis() and prints this epoch time. To demonstrate date arithmetic, it calculates the date seven days before the current date using currentDate.minusDays(7) and prints this result.
Next, it creates a specific LocalDate for January 1, 2023, and prints it. The program then compares the current date with this anotherDate using both isBefore and isAfter methods, printing whether the current date is before or after anotherDate. It further uses the compareTo method to compare the two dates, printing whether the current date is before, after, or equal to anotherDate based on the comparison result.
The program proceeds to work with the current date and time, including time zone information, by using ZonedDateTime.now(). A DateTimeFormatter is defined to format the date and time in a specific pattern. The program converts the current date and time to different time zones: GMT, CST (Central Standard Time), and IST (Indian Standard Time), using withZoneSameInstant(ZoneId.of("GMT")), ZoneId.of("CST", ZoneId.SHORT_IDS), and ZoneId.of("Asia/Kolkata"), respectively, and prints the formatted dates in these time zones.

# Day 18_1
public class Day18_1 which contains a static method isPrime and a main method. The isPrime method is designed to check whether a given integer is a prime number. It takes an integer parameter number and returns a boolean value. The method first checks if the number is less than or equal to 1, in which case it returns false because numbers less than or equal to 1 are not prime. If the number is greater than 1, it proceeds to a for loop that runs from 2 to the square root of the number (inclusive). This loop checks if the number is divisible by any integer in this range. If it finds any such integer, it returns false because the number is not prime. If the loop completes without finding any divisors, the method returns true, indicating the number is prime.
The main method is the entry point of the program. It calls the isPrime method twice with the arguments 5 and 4, respectively, and prints the results to the console. The output will be true for the input 5, since 5 is a prime number, and false for the input 4, since 4 is not a prime number (it is divisible by 2). This demonstrates the functionality of the isPrime method.

# Day 18_2
Day18_2 which contains a static method countVowels and a main method. The countVowels method is designed to count the number of vowels in a given string. It takes a string parameter input and returns an integer representing the number of vowels. The method initializes a counter vowelCount to zero. It then converts the input string to lowercase to ensure the method is case-insensitive when checking for vowels. Next, it iterates over each character in the string using a for loop. For each character, it checks if the character is one of the vowels ('a', 'e', 'i', 'o', 'u'). If it is, the counter vowelCount is incremented by one. After the loop completes, the method returns the total count of vowels found in the string.
The main method is the entry point of the program. It calls the countVowels method twice with the strings "Hello World" and "Java Programming", respectively, and prints the results to the console. The output for "Hello World" will be 3 because it contains the vowels 'e', 'o', and 'o'. The output for "Java Programming" will be 5 because it contains the vowels 'a', 'a', 'o', 'a', and 'i'. This demonstrates the functionality of the countVowels method.

# Day 19_1
 Random class from the java.util package, which is essential for generating pseudorandom numbers. Inside the main method of the Day19_1 class, a new Random object named random is instantiated. This object serves as the generator for random numbers in subsequent operations. The nextInt() method is then called on the random object to generate a random integer. This method produces a pseudorandom integer value within the full range of possible integers in Java, from negative Integer.MIN_VALUE to positive Integer.MAX_VALUE. The generated random number is stored in the variable randomNumber. Finally, the program prints out the generated random number using System.out.println(), displaying it alongside the string "Random number: " to provide context in the console output. This code snippet demonstrates the foundational use of the Random class for basic random number generation in Java programming, suitable for various applications requiring unpredictability and variability in data or simulation contexts.

 # Day 19_2
The Java program begins by importing the Random class from the java.util package, essential for generating pseudorandom numbers. Inside the main method of the Day19_2 class, two integer variables, min and max, are defined to specify the inclusive range [10, 20] within which the random number will be generated. A new Random object named random is instantiated to facilitate random number generation. The expression random.nextInt(max - min + 1) + min is used to generate a random integer within the specified range. Here, nextInt(max - min + 1) produces a random integer from 0 to 10 due to the calculation 20 - 10 + 1, and adding min ensures that the final generated number falls between 10 and 20. Finally, the program prints the generated random number alongside informative text using System.out.println(), displaying it formatted as "Random number between 10 and 20: " followed by the actual random number. This example showcases the utility of the Random class in Java for controlled random number generation, crucial in applications requiring unpredictability within defined bounds such as simulations, games, and statistical sampling.

# Day 20
The provided Java code demonstrates the usage of a `HashSet` to manage a collection of unique string values. The program begins by importing the `HashSet` and `Set` classes from the `java.util` package. Inside the `main` method, a `HashSet` named `stringSet` is initialized to store strings. Several fruit names are added to the set using the `add()` method. The program then checks for the presence of the value "Cherry" in the set using the `contains()` method and prints an appropriate message based on whether the value is found. Next, the program attempts to remove the value "Date" from the set using the `remove()` method, and it prints a message indicating whether the removal was successful. The current size of the set is printed using the `size()` method. The program proceeds to loop through the set and print each value using an enhanced for loop. Finally, all values are removed from the set using the `clear()` method, and the program prints the new size of the set, confirming that it is empty. This code effectively demonstrates the fundamental operations of adding, checking, removing, iterating, and clearing elements in a `HashSet`.

# Day 21
The given Java code demonstrates various operations using a `HashMap` to store and manage student roll numbers and names. The program begins by importing the necessary classes from the `java.util` package. Inside the `main` method, a `HashMap` named `students` is initialized with `Integer` keys for roll numbers and `String` values for student names. Five students are then added to the `HashMap` using the `put()` method. The program retrieves and prints the name of the student with roll number 3 using the `get()` method. It checks if roll number 4 exists in the `HashMap` with the `containsKey()` method and prints an appropriate message based on the check's result. Next, the student with roll number 2 is removed from the `HashMap` using the `remove()` method, and the updated size of the `HashMap` is printed. The program then iterates over the `HashMap` twice to print all student names: first using the `keySet()` method to loop through the keys, and then using the `entrySet()` method to loop through the key-value pairs. This code effectively demonstrates how to add, access, check existence, remove, and iterate over elements in a `HashMap`.

# Day 22
The provided Java code demonstrates the use of the `Stack` class from the `java.util` package to manage a collection of strings. The `main` method begins by creating an instance of a stack called `stack`. It then pushes three strings ("apple", "banana", and "orange") onto the stack. The `pop` method is called to remove the top element from the stack, which is "orange", and this removed item is printed to the console. Next, the `peek` method retrieves the current top element of the stack without removing it, which is "banana", and prints it. The code then checks if the stack contains the string "banana" using the `contains` method, printing an appropriate message based on the result. The current size of the stack is printed using the `size` method. Finally, the `clear` method empties the stack, and the `isEmpty` method confirms that the stack is now empty, with this status printed to the console.

# Day 23
This Java program demonstrates the use of a `Queue` implemented by a `LinkedList` to perform basic queue operations. The program starts by importing the necessary classes from the `java.util` package and defines the `Day23` class with a `main` method. Within the `main` method, a `Queue` of `String` type is initialized and populated with three elements: "Andreah," "Evelyn," and "Tatiana." The contents of the queue are then printed. The head element is removed using the `poll` method, and the removed element is displayed. The queue's state after removal is printed, showing the remaining elements. The program then retrieves and prints the head element using the `peek` method without removing it. It checks if a specific value, "Andreah," exists in the queue using the `contains` method and prints the result. Finally, the program prints the number of elements currently in the queue using the `size` method. This program showcases fundamental queue operations, including addition, removal, inspection, and size determination.

# Day 24_ Book
The `Day24_Book` class is an example of encapsulation in Java, where the data (attributes) and methods (behavior) of a book are wrapped together into a single unit. The class has private fields `title`, `author`, and `isCheckedOut` to store the book's details and its checkout status. Public methods such as `getTitle()`, `getAuthor()`, and `isCheckedOut()` provide controlled access to these fields, ensuring that they cannot be directly modified from outside the class. The methods `checkOut()` and `returnBook()` manage the checkout status of the book, while `displayInfo()` prints the book's details. This encapsulation hides the internal state of the book and enforces a controlled interaction through the public methods.

# Day 24_Member
The `Day24_Member` class exemplifies encapsulation by combining data (attributes) and methods (behavior) related to a library member into a single, cohesive unit. The class has private fields `name` and `memberId` to store the member's information. Public methods such as `getName()` and `getMemberId()` provide controlled access to these fields, preventing direct modification from outside the class. The methods `borrowBook(Day24_Book book)` and `returnBook(Day24_Book book)` allow the member to interact with `Day24_Book` objects, managing book borrowing and returning actions. The `displayInfo()` method prints the member's details. This encapsulation ensures that the internal state of the member is hidden and only accessible through defined methods, promoting data integrity and security.

# Day 24 _ Library
The `Day24_Library` class demonstrates encapsulation by encapsulating the data and behavior related to managing a library's collection of books and members. The class contains private fields `books` and `members`, which are lists storing `Day24_Book` and `Day24_Member` objects, respectively. The constructor initializes these lists. Public methods such as `addBook(Day24_Book book)` and `addMember(Day24_Member member)` allow adding books and members to the library, while `listBooks()` and `listMembers()` methods print the details of all books and members in the library. By encapsulating the management of books and members within the `Day24_Library` class, the internal state is hidden from external access, promoting data integrity and encapsulating the library's functionality within a well-defined interface.

# Day 24 _ Main
The `Day24_Main` class serves as the entry point for the simplified library management system, demonstrating how to use the encapsulated classes to manage books and members in a library. In the `main` method, a `Day24_Library` object is instantiated to manage the library's collection. Two `Day24_Book` objects are created with titles "Computer Architecture" and "Algorithm Design," authored by "Mushiri Nyaga" and "Ndinda Wilkister," respectively, and are added to the library's book list using the `addBook` method. Similarly, two `Day24_Member` objects named Alice and Bob with member IDs 1 and 2 are created and added to the library's member list using the `addMember` method. The `listBooks` and `listMembers` methods of the `Day24_Library` class are then called to display the current books and members. The program demonstrates book borrowing and returning by having Alice borrow and return "Computer Architecture," followed by Bob borrowing the same book and an attempt by Alice to borrow it again while it is still checked out. This sequence of operations illustrates the basic functionality of the library management system, showcasing encapsulation and interaction between objects.

# Day 25
The `Day25` class represents a user with six private fields: `id`, `firstName`, `lastName`, `email`, `city`, and `country`. The class includes a constructor that initializes these fields. It provides getter methods for each field, allowing their values to be accessed, and setter methods, allowing their values to be modified. Additionally, the class has a `getFullname` method that returns the user's full name by concatenating the `firstName` and `lastName` fields. The `main` method demonstrates creating an instance of the `Day25` class with specific values, and then it prints out the user's ID, full name, email, city, and country to the console. This example highlights basic object-oriented programming principles in Java, including encapsulation and the use of getters and setters.

# Day 26
The `Day26` class is a Java class designed to represent a user with attributes `firstname`, `lastname`, and `email`. It features three constructors to initialize objects with different sets of parameters: one that takes a first name and last name, another that takes only an email, and a third that takes all three attributes. The class includes getter methods for each attribute, allowing access to the private variables. The `toString` method is overridden to provide a readable string representation of a `Day26` object, displaying the first name, last name, and email. In the `main` method, three instances of the `Day26` class are created using the different constructors. These instances are then printed to the console, demonstrating the output format defined by the `toString` method. This class structure supports flexibility in how a `Day26` object can be instantiated, accommodating various use cases for initializing user data.

# Day 27
The provided code defines two Java classes within the `Inheritance` package: `User` and `Day27`. The `User` class, which serves as the parent class, contains basic fields such as `name`, `email`, and `age`, along with their respective getters and setters. The `Day27` class extends the `User` class and includes additional fields and constructors to represent both instructors and students. For instructors, it incorporates `qualification`, `coursesTaught`, and `salary`, while for students, it includes `registeredCourses`, `grade`, and `joiningYear`. The class also provides getter and setter methods for these fields. The `toString` method is overridden to display detailed information based on whether the instance represents an instructor or a student. The `main` method demonstrates creating instances of both instructor and student and prints their details.

# Day 28
The `Day28` class contains a `main` method which begins by creating an instance of the `Instructor` class with the name "Gregory Kamau" and an initial salary of 50000.0. It prints the initial salary using the `getSalary` method. The `incrementSalary` method is called with a parameter of 10, increasing the salary by 10%, and the new salary is printed. Following this, the `incrementSalary` method is called again with parameters of 5 and 2000, which applies a 5% increment and adds a bonus of 2000, and the updated salary is printed once more. The `Instructor` class itself has private fields `name` and `salary`, a constructor to initialize these fields, and two overloaded `incrementSalary` methods. The first `incrementSalary` method takes an integer percent and increases the salary by that percentage. The second `incrementSalary` method first calls the initial method with the percent parameter and then adds the specified bonus amount to the salary. Finally, the `getSalary` method returns the current salary.

# Day 29
The `Day29` class demonstrates inheritance and method overriding in Java through nested `User` and `Instructor` classes. The `User` class has fields for `firstname` and `lastname`, along with methods to retrieve these values and a method `getFullname` that returns the full name. The `Instructor` class extends `User` and overrides the `getFullname` method to prepend "Prof." to the full name. In the `main` method, an instance of `User` is created with the name "Fortune Kanyangi" and its full name is printed. Then, an instance of `Instructor` is created with the name "Jane Mwirigi", and the overridden full name, which includes the "Prof." prefix, is printed.

# Day 30
The code defines an abstract class `User` with private fields `name` and `email`, along with their respective getters and setters. The class constructor initializes these fields, and an abstract method `displayUserInfo` is declared, which must be implemented by any subclass. The `AdminUser` class extends `User` and provides a concrete implementation for the `displayUserInfo` method, printing the user's name and email with a specific format. The `Day30` class contains the `main` method, which creates an instance of `AdminUser` with sample data and calls the `displayUserInfo` method to demonstrate the functionality. This setup showcases inheritance and polymorphism, as the `AdminUser` subclass provides specific behavior for the abstract method defined in the `User` superclass.

# Day 31
The provided code illustrates the use of interfaces and method overloading in Java through three components: the `InstructorInterface`, the `Instructor` class, and the `Main` class. The `InstructorInterface` specifies a contract with methods for retrieving and incrementing an instructor's salary. The `Instructor` class implements this interface, providing concrete methods to get the salary and increment it either by a fixed amount or by a percentage, depending on a boolean flag. In the `Main` class, an `Instructor` object is created, and its salary is manipulated to demonstrate the functionality. The salary is initially set to 50000, then incremented by a fixed amount of 5000 and a percentage of 10%, showing how the class methods affect the salary. This example highlights how interfaces define expected behavior, how classes implement that behavior, and how method overloading allows different forms of salary increments.

# Day 32
The provided code demonstrates polymorphism and method overloading in Java. It includes three classes: `Person`, `Instructor`, and `PolymorphismDemo`. The `Person` class has a `name` property and a `display` method to print the name. The `Instructor` class extends `Person`, adding a `salary` property, a method to display the instructor's details (including role and salary), and two overloaded methods to increment the salary, one taking a single amount and the other taking both an amount and a bonus. In the `PolymorphismDemo` class, the `main` method creates an `Instructor` object and a `Student` object, both referred to as `Person`. It calls the `display` method on both objects, showcasing polymorphism as the `Instructor`'s `display` method is used for the `Instructor` object. The code then uses the `instanceof` operator to check if the `Person` object is an instance of `Instructor`, casts it to `Instructor`, and calls the salary increment methods, first with a single parameter and then with two parameters, displaying the updated salary each time. This highlights how polymorphism allows subclass objects to be used where superclass objects are expected, and how method overloading provides multiple ways to perform an operation.

# Day 33
This code demonstrates Java object serialization and deserialization, which allows objects to be converted into a byte stream for storage and later reconstructed. The `Instructor` and `Student` classes implement the `Serializable` interface to enable this process. The `SerializeDemo` class contains the `serializeObject` method that writes an object's state to a file, while the `DeserializeDemo` class provides the `deserializeObject` method to read the object's state from a file. In the `Main` class, instances of `Instructor` and `Student` are created, serialized to files ("instructor.ser" and "student.ser"), and then deserialized back into objects. The deserialized objects are printed to the console, demonstrating that their state has been preserved across the serialization and deserialization process.

# Day 34
This code demonstrates the use of custom annotations for validating fields in Java classes. The `Email`, `NotNull`, `Min`, `Max`, and `Size` annotations are defined with parameters for specifying validation rules and messages. The `Instructor` and `Student` classes use these annotations to enforce constraints on their fields: `id`, `name`, `email`, and `salary` or `age`. For instance, `@NotNull` ensures fields are not null, `@Size` enforces the length of the name, and `@Email` validates the email format. The `Main` class creates instances of `Student` and `Instructor`, printing their details to the console. Although the validation annotations are defined, the code does not currently perform actual validation checks during runtime. Proper validation would require integrating a validation framework like Hibernate Validator.

# Day 35
The provided Java code snippets demonstrate various file operations using the `java.nio.file` package. The first snippet checks if a file exists in a specified directory. The second snippet deletes a specified file, handling any potential `IOException`. The third snippet creates a directory and a file within it. The fourth snippet retrieves and prints details about a specified file, including its name, parent directory, and extension. The fifth snippet renames a file, moving it to a new path and handling any potential `IOException`. These examples showcase basic file handling operations in Java, such as checking existence, deletion, creation, retrieval of details, and renaming of files.

# Day 36
The code in the `Main` class, within the `Day36` package, demonstrates various ways to read from and write to files in Java, while also handling potential exceptions. Initially, the program reads from a file named `input.txt` using three different approaches: `Paths.get` with `Scanner`, `File` with `Scanner`, and `FileReader` with `Scanner`, displaying the file contents to the console in each case. Appropriate `IOException` and `FileNotFoundException` exceptions are caught and handled to manage file access errors. Following the reading operations, the code proceeds to write data to two different files. First, it writes to `output.txt` using a `FileWriter`, and then it writes to `output_buffered.txt` using a `BufferedWriter`, with both writing operations enclosed in try-with-resources statements to ensure proper resource management. If any `IOException` occurs during these writing processes, it is caught and a relevant error message is displayed. This comprehensive handling of file I/O operations highlights various methods of file reading and writing in Java, showcasing the use of different classes and exception handling mechanisms.

# Day 37
The `Main` class in this code demonstrates reading and processing data from both a CSV file and a JSON file, then sorting and displaying this data. The `Instructor` class is defined with fields for ID, first name, last name, qualification, department, and experience, along with the necessary getters, setters, and a `toString` method for convenient display. In the `main` method, student details are read from a CSV file named `students.csv` using the `CSVReader` class from the `com.opencsv` library. The data is stored in a list of string arrays, which is then sorted by the second element (assumed to be the student's name) and printed to the console. Exception handling ensures that any issues during file reading are captured and reported. Next, instructor details are read from a JSON file named `instructors.json` using the `ObjectMapper` class from the `com.fasterxml.jackson.databind` library. The JSON data is deserialized into a list of `Instructor` objects, which are stored in a map with the instructor ID as the key. The instructor details are then sorted by ID and printed to the console. Any IOExceptions encountered during the JSON file reading are also appropriately handled and reported. This code exemplifies the integration of different libraries for handling CSV and JSON data, showcasing reading, sorting, and displaying data while managing potential exceptions.

# Day 38
The provided Java code includes three distinct classes, each demonstrating specific exception handling techniques. The `DivisionCalculator` class attempts to divide two integers, `num1` and `num2`, using a `divide` method. When `num2` is zero, an `ArithmeticException` is caught, and a message is printed to indicate that division by zero is not allowed. The `FileReaderExample` class reads and prints the contents of a file named `example.txt` using a `Scanner`. If the file is not found, a `FileNotFoundException` is caught, and an error message prompts the user to check the file path. Lastly, the `SquareCalculator` class prompts the user to enter an integer, reads the input, and calculates its square. If the input is not a numeric value, a `NumberFormatException` is caught, and an error message is displayed, instructing the user to enter a valid number. Each class demonstrates effective handling of common runtime exceptions to ensure robust and user-friendly program behavior.

# Day 39
The provided code consists of four separate Java programs, each demonstrating the use of streams and lambdas for different tasks. The first program, `FilterStrings`, filters a list of strings to retain only those that start with the letter "b" and prints the filtered list. The second program, `FilterStudents`, reads student data from a CSV file, filters the students with grades greater than 3, and prints the filtered list of students. It uses `BufferedReader` to read the file, splits each line by a comma, and maps the data to a `Student` object. The `Student` class is defined within the same program with `name` and `grade` attributes.

The third program, `MapToSquares`, takes a list of integers, maps each integer to its square, and prints the resulting list of squares. The fourth program, `ParallelPrimeFinder`, finds prime numbers in a list of integers using a parallel stream, which allows concurrent processing. It defines a method `isPrime` to check for prime numbers and uses this method in the `filter` operation of the parallel stream. The filtered list of prime numbers is then printed.

Together, these programs illustrate how Java streams and lambdas can be used to perform various data processing tasks in a concise and functional programming style.


